<h1 style="text-align:center">Unix 接口设计模式</h1>

## Introduction
简单、一次只做一件事、面向数据流的一层层改变、分利组合提供无限可能。

## Table of contents
+ [过滤器模式](#过滤器模式)
+ [Cantrip模式](#Cantrip模式)
+ [源模式](#源模式)
+ [接收器模式](#接收器模式)
+ [编译器模式](#编译器模式)
+ [ed模式](#ed模式)
+ [Roguelike模式](#Roguelike模式)
+ [引擎与接口分离模式](#引擎与接口分离模式)
+ [配置者/执行者组合](#配置者/执行者组合)
+ [假脱机/守护进程组合](#假脱机/守护进程组合)
+ [驱动与引擎组合](#驱动与引擎组合)
+ [客户端与服务器组合](#客户端与服务器组合)
+ [CLI服务器模式](#CLI服务器模式)
+ [基于语言的接口模式](#基于语言的接口模式)


## 过滤器模式

> 过滤器模式的程序接收标准输入的数据，转换为某种格式后，再将结果发送到标准输出端。例如`grep`

+ Postel原则：严出宽进
+ 在过滤时，不需要的信息绝不丢弃
+ 在过滤时，绝不增加无用数据

## Cantrip模式

> Cantrip模式, 没有输入，没有输出，只被调用一次，产生退出状态数值，它的行为只能由启动条件来控制。例如`clear`、`rm`、`touch`。

## 源模式

> 源模式是只有输出，没有输入的模式，它的行为只能由启动条件来控制。例如`ls`、`pwd`、`ps`。

## 接收器模式

> 接收器模式，只接收标准输入，不产生标准输出，它可以把标准输入的数据重定向到其他地方。

## 编译器模式

> 编译器模式没有标准输入、也没有标准输出，有错误输出。从命令行接收资源名，通过某种方式转换这些资源。例如`gcc`

## ed模式

> 交互设计模式、由用户持续的会话驱动。例如`shell`

## Roguelike模式

> 使用全屏幕、支持可视界面风格，但使用字符列阵显示，而非图形和鼠标界面。例如`vi`

## 引擎与接口分离模式

> 将程序分解成几个相互通讯的进程

GUI原型的建议（MVC）

+ 模型(引擎)：模型包含了应用程序专用定义域的数据结构和逻辑
+ 视图：将定义域内的对象渲染成可视状态，由模型通知更新
+ 控制器：处理用户的请求并将它们作为命令传递给模型

## 配置者/执行者组合

> 接口部分控制运行时无需用户命令的过滤器或者类似守护进程的启动环境，例如`pg_ctl`

间接的启动程序，简化配置。

## 假脱机/守护进程组合

> spooler将工作请求和数据放到待处理区域，守护进程永远在后台运行、轮询spool目录，发现请求处理请求，如果成功则移除spool区域的作业。 

spooler/daemon 系统由四个部分组成

+ 作业发布者
+ 队列列表
+ 作业撤销功能
+ 带有dpooling的守护进程

## 驱动与引擎组合

> 与spooler/service不同，组合的接口部分，需要向引擎提供命令并在启动后解释引擎的输出

## 客户端与服务器组合

> 客户端发送指令，显示数据；后台程序来调度对某种共享资源的访问。

## CLI服务器模式

> 统一掌握服务器，启动服务器进程，服务器从标准输入接收命令，将响应发送到标准输出。掌握程序确保服务器的stdin和stdout连接到专用的tcp/ip端口

## 基于语言的接口模式

> 微型语言